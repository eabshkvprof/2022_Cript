
#  S-AES : ПРАКТИКА. БАЗОВЫЕ ФУНКЦИИ

## ДВОИЧНЫЙ КОД В ЭКВИВАЛЕНТНОЕ 10-Е ЦЕЛОЕ БЕЗ ЗНАКА

```python
def bin_list_2_num (bin_list):
    decimal_num = 0
    n = len(bin_list)
    for  i in range (n):
        decimal_num += bin_list[n-1-i]*2**i
    return decimal_num
```

## ФУНКЦИЯ "ИСКЛЮЧИТЕЛЬНОЕ ИЛИ"

```python
#  --------------------------------------------------------
#  ИСКЛЮЧИТЕЛЬНОЕ ИЛИ НАД ДВУМЯ ДВОИЧНЫМИ n-разрядными кодами
#  !!! В Питоне есть операция побитного исключительного или: op1 ^ op2 !!!
#  --------------------------------------------------------
def operxor (code1,code2):
    if len(code1) == len(code2): # проверка равенства разрядности кодов
        # формируем пустой "двоичный" список n -  разрядов
        result_code = [-1] * len(code1)

        for i in range (len(code1)):
            result_code [i] = 0
            if code1[i] != code2[i] :  result_code [i] = 1
        return result_code

    else :   # Если разрядности кодов не равны возвращаем СТРОКУ ОХ-ОХ
        return  'Oh_Oh'
```


# БЛОК в СОСТОЯНИЕ / СОСТОЯНИЕ в БЛОК

```python
#  --------------------------------------------------------
#  Функция преобразования блока в матрицу состояний
#  Блок - 16 бит = 4 тетрады = 2 байта
#  Состяние матрица 2 Х 2 = 4 тетрады
#  --------------------------------------------------------
def block2state (block):
    if len(block) != 4 : return 'No No'
    s = [[[0,0,0,0],[0,0,0,0]],
         [[0,0,0,0],[0,0,0,0]]]

    s[0][0]=block[0]
    s[1][0]=block[1]
    s[0][1]=block[2]
    s[1][1]=block[3]

    return s

#  --------------------------------------------------------
#  Функция преобразования матрицы состояния в блок
#  Блок - 16 бит = 4 тетрады = 2 байта
#  Состяние матрица 2 Х 2 = 4 тетрады
#  --------------------------------------------------------
def state2block (state):
    if len(state) != 2 : return 'No No'
    bl = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]

    bl[0] = state[0][0]
    bl[1] = state[1][0]
    bl[2] = state[0][1]
    bl[3] = state[1][1]

    return bl
```

# ФУНКЦИЯ ПОДСТАНОВКИ SubNibbles
```python
#  --------------------------------------------------------
#  Функция SUBNIBBLES
#  На входе состояние
#  На выходе новое состояние
#  --------------------------------------------------------
def subnibbles (state):
    if len(state) != 2 : return 'No State'
    directmatrix = [[[1,0,0,1],[0,1,0,0],[1,0,1,0],[1,0,1,1]],
                    [[1,1,0,1],[0,0,0,1],[1,0,0,0],[0,1,0,1]],
                    [[0,1,1,0],[0,0,1,0],[0,0,0,0],[0,0,1,1]],
                    [[1,1,0,0],[1,1,1,0],[1,1,1,1],[0,1,1,1]]]
    s = [[[0,0,0,0],[0,0,0,0]],
         [[0,0,0,0],[0,0,0,0]]]    

    for i in range (2):
        for j in range (2):
            nibble = state [i][j]
            row = nibble[0]*2+nibble[1]
            clm = nibble[2]*2+nibble[3]
            s [i][j] = directmatrix[row][clm]

    return s        
```

## ФУНКЦИЯ СДВИГА СТРОК ShiftRows
```python
#  --------------------------------------------------------
#  Сдвиг строк состяния
#  На входе состояние
#  На выходе новое состояние,
#  вторя строка сдвинута
#  --------------------------------------------------------
def shiftrows (state):
    '''
    На входе состояние
    На выходе новое состояние
    Первая строка без сдвига, вторая = тетрады поменялись местами
    '''
    if len(state) != 2 : return 'No State'

    s = [[[0,0,0,0],[0,0,0,0]],
         [[0,0,0,0],[0,0,0,0]]]    
    state[0][0]
    s[0][0] = state[0][0]
    s[0][1] = state[0][1]
    s[1][0] = state[1][1]
    s[1][1] = state[1][0]

    return s        

```

## ФУНКЦИЯ СМЕШЕНИЯ КОЛОНОК MixColums
```python
#  --------------------------------------------------------
#  Функция MIXCILUMS
#  На входе состояние
#  На выходе новое состояние
#  ВНИМАНИЕ!!! В данной версии умножение по модулю в поле Галуа  ВЫПЛНЯЕТСЯ НЕВЕРНО !!!!
#  --------------------------------------------------------
def mixcolums (state):
    if len(state) != 2 : return 'No State'
    const = [[[0,0,0,1],[0,1,0,0]],
             [[0,1,0,0],[0,0,0,1]]]
    s = [[[0,0,0,0],[0,0,0,0]],
         [[0,0,0,0],[0,0,0,0]]]    

    #  SOUT[0][0] = CONST[0][0]*STATS[0][0]+CONST[0][1]*STATS[1][0]
    #  SOUT[0][0] = STATS[0][0]+4*STATS[1][0] !!! УМНОЖЕНИЕ ИМИТИРУЕМ СДВИГОМ на 2 разряда
    temp_ = [state[1][0][1],state[1][0][0],0,0]
    s[0][0]= operxor (state[0][0],temp_)

    #  SOUT[1][0] = CONST[1][0]*STATS[0][0]+CONST[1][1]*STATS[1][0]
    #  SOUT[1][0] = 4*STATS[0][0]+STATS[1][0]  !!! УМНОЖЕНИЕ ИМИТИРУЕМ СДВИГОМ на 2 разряда
    temp_ = [state[1][0][1],state[1][0][0],0,0]
    s[1][0]= operxor (state[0][0],temp_)

    #  SOUT[0][1] = CONST[0][0]*STATS[0][1]+CONST[0][1]*STATS[1][1]
    #  SOUT[0][1] = STATS[0][1]+4*STATS[1][1] !!! УМНОЖЕНИЕ ИМИТИРУЕМ СДВИГОМ на 2 разряда
    temp_ = [state[1][1][1],state[1][1][0],0,0]
    s[0][1]= operxor (state[0][1],temp_)

    #  SOUT[1][1] = CONST[1][0]*STATS[0][1]+CONSTS[1][1]*STAT[1][1]
    #  SOUT[1][1] = 4*STATS[0][1]+STATS[1][1]  !!! УМНОЖЕНИЕ ИМИТИРУЕМ СДВИГОМ на 2 разряда
    temp_ = [state[0][1][1],state[0][1][0],0,0]
    s[0][1]= operxor (state[1][1],temp_)

    return s

```

## ДОБАВЛЕНИЕ КЛЮЧА РАУНДА

```python
#  --------------------------------------------------------
#  Функция ADDROUNDKEY
#  На входе состояние и 4 тетрады ключа
#  
#  На выходе новое состояние
#  --------------------------------------------------------
def addroundkey (state, key):
    if len(key) != 4 : return 'No Key'
    if len(state) != 2 : return 'No State'
    s = [[[0,0,0,0],[0,0,0,0]],
         [[0,0,0,0],[0,0,0,0]]]
    s[0][0] = operxor(key[0],state[0][0])
    s[1][0] = operxor(key[1],state[1][0])
    s[0][1] = operxor(key[2],state[0][1])
    s[1][1] = operxor(key[3],state[1][1])

    return s

```

## ГЕНЕРАТОР РАУНДОВЫХ КЛЮЧЕЙ

```python
def tgen (word, round_num):
    '''
    Функция генерации временного слова для генерации ключа
    Принимает 2 тетрады слова от раунда (-1 -е слово )
    Принимает номер раунда 1 или 2
    вовращает временную константу

    '''
    directmatrix = [[[1,0,0,1],[0,1,0,0],[1,0,1,0],[1,0,1,1]],
                    [[1,1,0,1],[0,0,0,1],[1,0,0,0],[0,1,0,1]],
                    [[0,1,1,0],[0,0,1,0],[0,0,0,0],[0,0,1,1]],
                    [[1,1,0,0],[1,1,1,0],[1,1,1,1],[0,1,1,1]]]

    # Принятое слово
    w = [word[0],word[1]]

    # Rot Word делаем сдвиг
    w1 = [[],[]]       
    w1[0] = w[1]       
    w1[1] = w[0]           

    # SubWord делаем подстановку
    w2 = [[ ],[]]

    for i in range (2):
        nibble = w1[i]
        row = nibble[0]*2+nibble[1]
        clm = nibble[2]*2+nibble[3]
        w2 [i] = directmatrix[row][clm]

    # Формируем временное слово сложением с константой RCon
    t = [[],[]]
    t[1] = w2[1]
    # Учитываем номер раунда
    if round_num == 1:
        t[0] = operxor (w2[0],[1,0,0,0])
    else :
        t[0] = operxor (w2[0],[0,0,1,1])

    return t

def keyexpand (key):
    '''
    Принимает 4 тетрады секретного ключа шифра
    Вовзращает список 3 списка по 4 элемента - тетрады ключа раунда

    '''

    if len(key) != 4 :
            return 'Secret key is not correction !!!'

    round_0_key = [[],[],[],[]]
    round_1_key = [[],[],[],[]]
    round_2_key = [[],[],[],[]]

    # round_0 key gen
    round_0_key[0] = key[0]
    round_0_key[1] = key[1]
    round_0_key[2] = key[2]
    round_0_key[3] = key[3]

    word_1 = [key[2],key[3]]
    t2 = tgen (word_1, 1)
    # round_1 key gen
    round_1_key[0] = operxor (key[0],t2[0])
    round_1_key[1] = operxor (key[1],t2[1])
    round_1_key[2] = operxor (key[2],round_1_key[0])
    round_1_key[3] = operxor (key[3],round_1_key[1])


    word_3 = [round_1_key[2],round_1_key[3]]
    t4 = tgen (word_3, 2)

    # round_2 key gen
    round_2_key[0] = operxor (round_1_key[0],t4[0])
    round_2_key[1] = operxor (round_1_key[1],t4[1])
    round_2_key[2] = operxor (round_1_key[2],round_2_key[0])
    round_2_key[3] = operxor (round_1_key[3],round_2_key[1])


    return [round_0_key, round_1_key, round_2_key]
```
